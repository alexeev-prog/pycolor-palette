# Правильный путь создания python-библиотеки: от создания до публикации
Привет, хабр! Стоит ли говорить, что Python ОЧЕНЬ и ОЧЕНЬ популярный язык программирования, местами даже догоняя JavaScript.

В мире программирования создание собственных библиотек - это не просто возможность пополнения своего портфолио или способ структурировать код, а настоящий акт творческого самовыражения (и иногда велосипедостроения). Каждый разработчик иногда использовал в нескольких своих проектах однообразный код, который приходилось каждый раз перемещать. Да и хотя-бы как упаковать свои идеи и знания в удобный и доступный формат, которым можно будет поделиться с сообществом.

Если вы ловили себя на мысли: "А почему мне бы не создать свою полноценную библиотеку?", то я рекомендую прочитать вам мою статью.

Эту статью вы можете использовать как шпаргалку для создания своих Python-библиотек. Я полностью расскажу все этапы создания библиотеки: документация, тестирование, архитектура, публикация и управление зависимостями

Некоторые из вас могут подумать что мы изобретаем велосипед. А я в ответ скажу - сможете ли вы прямо сейчас, без подсказок, только по памяти, нарисовать велосипед без ошибок?

---

Итак, как обычно начинается создание проектов на python? Банально создание виртуального окружения

```bash
python3 -m venv venv
source venv/bin/activate
```

Но в этом проекте я решил отойти от такого способа, и использовать вместо этого систему правлению проектами Poetry. Poetry — это инструмент для управления зависимостями и сборкой пакетов в Python. А также при помощи Poetry очень легко опубликовать свою библиотеку на PyPi!

В Poetry представлен полный набор инструментов, которые могут понадобиться для детерминированного управления проектами на Python. В том числе, сборка пакетов, поддержка разных версий языка, тестирование и развертывание проектов.

Все началось с того, что создателю Poetry Себастьену Юстасу потребовался единый инструмент для управления проектами от начала до конца, надежный и интуитивно понятный, который бы мог использоваться и в рамках сообщества. Одного лишь менеджера зависимостей было недостаточно, чтобы управлять запуском тестов, процессом развертывания и всем созависимым окружением. Этот функционал находится за гранью возможностей обычных пакетных менеджеров, таких как Pip или Conda. Так появился Python Poetry.

Установить poetry можно через pipx: `pipx install poetry` и через pip: `pip install poetry --break-system-requirements`. Это установит poetry глобально во всю систему.

Итак, давайте создадим проект при помощи poetry и установим зависимости:

```bash
poetry new <имя_проекта>
cd <имя_проекта>
poetry shell
poetry add asttokens executing colorama rich ruff loguru pygments
```










# Пишем свою программу для бенчмаркинга и мониторинга ресурсов на Python
Недавно я сильно заинтересовался компьютерами, их сборкой, да и устройством компьютера в целом. И также я решил, что давно не писал стоящие пет-проекты с более-менее организованной архитектурой.

Собственно, здесь я и решил что хорошей идей будет создание программы для бенчмаркинга и мониторинга ресурсов ПК. Т.к. часто требуется измерить температуру, состояние процессора, ОЗУ, диска и в принципе ОС. Довольно интересный проект с точки реализации и анализа компьютера, а также даже он может пригодиться в реальной жизни, а не просто "в стол".

В этой статье мы рассмотрим: как получать данные о ПК, как их хранить, обрабатывать и анализировать, как создавать бенчмарки, а также как выстроить грамотно интерфейс и инфракструктуру проекта. Все это будет реализовано на языке программирования Python.

Я вдохновлялся другими популярными программами для мониторинга системных ресурсов: CPUZ, GPUZ, AIDA64 и другие.

Не буду долго тянуть, приступим!

---

Итак, как обычно начинается создание проектов на python? Банально создание виртуального окружения

```bash
python3 -m venv venv
source venv/bin/activate
```

Но в этом проекте я решил отойти от такого способа, и использовать вместо этого систему правлению проектами Poetry. Poetry — это инструмент для управления зависимостями и сборкой пакетов в Python.

В Poetry представлен полный набор инструментов, которые могут понадобиться для детерминированного управления проектами на Python. В том числе, сборка пакетов, поддержка разных версий языка, тестирование и развертывание проектов.

Все началось с того, что создателю Poetry Себастьену Юстасу потребовался единый инструмент для управления проектами от начала до конца, надежный и интуитивно понятный, который бы мог использоваться и в рамках сообщества. Одного лишь менеджера зависимостей было недостаточно, чтобы управлять запуском тестов, процессом развертывания и всем созависимым окружением. Этот функционал находится за гранью возможностей обычных пакетных менеджеров, таких как Pip или Conda. Так появился Python Poetry.

Установить poetry можно через pipx: `pipx install poetry` и через pip: `pip install poetry --break-system-requirements`. Это установит poetry глобально во всю систему.

Итак, давайте создадим проект при помощи poetry и установим зависимости:

```bash
poetry new <имя_проекта>
cd <имя_проекта>
poetry add rich matplotlib psutil py-cpuinfo pyqt5 numpy sympy diskinfo
poetry shell
poetry install
```

Все эти библиотеки будут нужны - для бенчмаркинга, получения информации о ПК. Например rich для просто красивого вывода; matplotlib для диаграмм; psutil, py-cpuinfo и diskinfo для получения информации о ПК, numpy и sympy для математических вычислений в бенчмарке, а pyqt5 для GUI.

poetry shell активирует шелл с виртуальным окружением, а poetry install установит зависимости из файла poetry.lock.

Итак, а теперь начнем писать код.

# Структура проекта
В этой статье я буду создавать библиотеку pycolor_palette-loguru - простой модуль для различных цветоных сообшений и дебага.

Вы можете посмотреть репозиторий по [ссылке](https://github.com/alexeev-prog/pycolor-palette).

Структуру проекта вы видите ниже:

```
.
├── docs/
├── example.py
├── poetry.lock
├── pycolor_palette_loguru
│   ├── __init__.py
│   ├── logger
│   │   ├── __init__.py
│   │   ├── logger.py
│   ├── paint.py
│   └── pygments_colorschemes.py
├── pyproject.toml
├── README.md
└── tests/
```

При использование poetry, README.md, pyproject.toml, tests и директория вашей библиотеки (в моем случае pycolor_palette_loguru) будут созданы сами. poetry.lock - лок файл, также создается poetry.

Директория docs нужна для документации, tests для тестов.

Полная структура кода (из корня репозитория):

```
.
├── Doxyfile
├── LICENSE
├── pycolor-palette
│   ├── docs
│   │   └── ru
│   │       └── article.md
│   ├── example.py
│   ├── poetry.lock
│   ├── pycolor_palette_loguru
│   │   ├── __init__.py
│   │   ├── logger
│   │   │   ├── __init__.py
│   │   │   ├── logger.py
│   │   │   └── __pycache__
│   │   │       ├── __init__.cpython-312.pyc
│   │   │       └── logger.cpython-312.pyc
│   │   ├── paint.py
│   │   ├── __pycache__
│   │   │   ├── __init__.cpython-312.pyc
│   │   │   ├── paint.cpython-312.pyc
│   │   │   └── pygments_colorschemes.cpython-312.pyc
│   │   └── pygments_colorschemes.py
│   ├── pyproject.toml
│   ├── README.md
│   └── tests
│       └── __init__.py
└── README.md
```

Итак, начнем работу над проектом с документации.

# Создание документации при помощи Doxygen
В этом разделе я расскажу о системе документирования исходных текстов Doxygen, которая на сегодняшний день, по имеющему основания заявлению разработчиков, стала фактически стандартом для документирования программного обеспечения, написанного на языке python, а также получила пусть и менее широкое распространение и среди ряда других языков.

Устанавливается Doxygen просто:

```bash
sudo pacman -S doxygen # Arch
sudo apt install doxygen # Ubuntu/Debian
```

Суть автоматизированного софта для генерации документации такая: на вход подаются файлы исходного кода, комментированные особым образом, а на выходе мы получаем структуированный формат документации.

Рассматриваемая система Doxygen как раз и выполняет эту задачу: она позволяет генерировать на основе исходного кода, содержащего комментарии специального вида, красивую и удобную документацию, содержащую в себе ссылки, диаграммы классов, вызовов и т.п. в различных форматах: HTML, LaTeX, CHM, RTF, PostScript, PDF, man-страницы.

В большинстве случаев Doxygen используется для документации программного обеспечения, написанного на языке C++, однако на самом деле данная система поддерживает гораздо большое число других языков: C, Objective-C, C#, PHP, Java, Python, IDL, Fortran, VHDL, Tcl, и частично D.

Итак, сначала нам нужно будет перейти в рабочую директорию и создать Doxyfile - файл конфигурации:

```bash
doxygen -g
```

В Doxyfile содержится краткое описание проекта, его версия и подобные вещи. Некоторые значения желательно сразу изменить.

Вот основные значения:

```bash
PROJECT_NAME           = "Project Name"             # Имя проекта
PROJECT_NUMBER         = 0.1.0                      # Версия проекта
PROJECT_BRIEF          = "Yet another project"      # Краткое описание проекта
OUTPUT_DIRECTORY       = docs                       # Куда складывать сгенерированную документацию
OUTPUT_LANGUAGE        = English                    # Язык документации
GENERATE_LATEX         = YES                        # Генерация LaTeX
INPUT                  = src include                # Директории, где искать файлы
RECURSIVE              = YES                        # Рекурсивный обход директорий
USE_MATHJAX            = YES                        # Использование mathjax (для latex в html)
```

 + PROJECT_NAME - название проекта.
 + PROJECT_NUMBER - версия проекта. Я придерживаюсь схемы "major.minor.patch".
 + PROJECT_BRIEF - краткое описание проекта.
 + OUTPUT_DIRECTORY - директория, куда будет записываться созданная документация.
 + OUTPUT_LANGUAGE - язык документации (доступные значения: Afrikaans, Arabic, Armenian, Brazilian, Bulgarian, Catalan, Chinese, Chinese-Traditional, Croatian, Czech, Danish, Dutch, English (United States), Esperanto, Farsi (Persian), Finnish, French, German, Greek, Hindi, Hungarian, Indonesian, Italian, Japanese, Japanese-en (Japanese with English messages), Korean, Korean-en (Korean with English messages), Latvian, Lithuanian, Macedonian, Norwegian, Persian (Farsi), Polish, Portuguese, Romanian, Russian, Serbian, Serbian-Cyrillic, Slovak, Slovene, Spanish, Swedish, Turkish, Ukrainian and Vietnamese).
 + GENERATE_LATEX - позволяет генерировать LaTeX.
 + INPUT - директории, откуда будет браться исходный код. Разделяются пробелами.
 + RECURSIVE - рекурсивный обход директорий.
 + USE_MATHJAX - для использования latex-формул в html.

Больше настроек вы можете посмотреть в [этой статье](https://habr.com/ru/articles/252443/).

## Кастомизация
Дефолтный стиль, мягко говоря, некрасивый. Поэтому мы будем использовать кастомную css-тему:

```bash
HTML_STYLESHEET        = ./docs/doxygen-styles.css # путь до css стилей
```

Данный файл стилей вы можете скачать [отсюда](https://raw.githubusercontent.com/jothepro/doxygen-awesome-css/refs/heads/main/doxygen-awesome.css).

Посмотреть, что получилось у меня, вы можете по [ссылке](https://alexeev-prog.github.io/pycolor-palette). А мой Doxyfile [здесь](https://github.com/alexeev-prog/pycolor-palette/blob/main/Doxyfile).

## Форма написания комментариев
Документация кода в Doxygen осуществляется при помощи документирующего блока. При этом существует два подхода к его размещению. Он может быть размещен перед или после объявления или определения класса, члена класса, функции, пространства имён и т.д.

Для того, чтобы doxygen правильно создал документацию, стоит следовать стилистике написания комментариев. Рассмотрим пример:

```python
def debug_message(text: str, highlight: bool=False) -> str:
    """
    print debug message

    :param      text:       The text
    :type       text:       str
    :param      highlight:  The highlight
    :type       highlight:  bool

    :returns:   message
    :rtype:     str
    """
    prefix = f'{BG.blue}{FG.black}' if highlight else f'{FG.blue}'
    message = '%s%-*s | %-*s%s ::: %s%s' % (prefix, 20, datetime.now().strftime('%Y-%m-%d %H:%M:%S'), 
                                        20, 'DEBUG', Style.reset, text, Style.reset)
    print(message)
```

 + @brief - краткое описание
 + @details - детали, подробное описание
 + @todo - что-то нужно доделать. Doxygen генерирует отдельную страницу со списком всех @todo
 + @warning - предупреждение
 + @ref - ссылка на связанный класс или метод
 + @param - передаваемый параметр, имеет направление ([in], [out], [in,out])
 + @return - возвращаемое значение

Также мы можем использовать latex-формулы: чтобы обозначить ее, надо в начале и в конце вставить `\f$`. Для создания latex-формул можно использовать [онлайн редактор latex](https://latexeditor.lagrida.com/).

Также существуют следующие метки:

 + @authors - автор/ы
 + @version - версия
 + @date - дата
 + @bug - известные ошибки
 + @copyright - лицензия
 + @example - файл примера работы
 + @throws или @raise - исключение во время работы
 + @mainpage Title — комментарий содержит текст для титульного листа документации
 + @file fname — описание конкретного файла
 + @deprecated — помечает класс или метод устаревшим. Как и с @todo, Doxygen генерирует отдельную страницу со списком всех устаревших классов и методов

В действительности, Doxygen поддерживает куда больше команд. Например, он позволяет писать многостраничную (@page) документацию с разделами (@section) и подразделами (@subsection), указывать версии методов и классов (@version), и не только.

Больше можно прочитать [здесь](https://habr.com/ru/articles/252101/).

## Деплой документации на github-pages
Для начала создадим репозиторий на GitHub. Откройте главную вкладку репозитория.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/361/57b/b30/36157bb305d2cc9b52f0415fcc879917.png)

Перейдите на вкладку Settings и откройте раздел Pages:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/8ea/a5d/fd3/8eaa5dfd38f145a20fffe1dfb9d2dc8b.png)

В этом разделе выберете Static HTML и нажмите кнопку Configure.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/f8e/24b/40d/f8e24b40d0d63c69c3ab7b0aea39b16d.png)

Откроется файл конфигурации задачи для CI/CD пайплайна. Все настройки хранятся в static.yaml файле. С помощью пайплайна можно вызывать системные команды. Вызов всех команд описывается с помощью шагов. Описание шагов начинается после строки steps. Путь к этой строке: jobs -> deploy -> steps.

Первые два шага по умолчанию выглядят так:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/e27/cc2/ec7/e27cc2ec74ba9151ee5a074a427a4c94.png)

При обновлении GitHub Pages может что-то поменяться, но я не думаю, что будет сложно понять, где надо писать свои шаги.

Теперь требуется добавить шаги с установкой Doxygen. В качестве системы используется Ubuntu, а значит пакеты устанавливаются через apt.

```yml
# Install Doxygen
- name: Install Doxygen
  run: sudo apt install doxygen && doxygen --version
# Create documentation   
- name: Create documentation     
  run: doxygen
```

Документация создается, но надо ее развернуть. Для этого необходимо указать путь к папке с index.html в шаге Upload artifact. Путь к главной странице сайта: ./html/index.html. Тогда этот шаг будет выглядеть так:

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/c7e/5b5/8e4/c7e5b58e4b99d12b4eda29bc68839e71.png)

Я же указал в конфигурации Doxyfile, что документация сохраняется в docs, поэтому я указываю путь ./docs/html/index.html.

На этом настройка закончена. Ссылка на документацию находится в раздел Settings -> Pages. То есть `<username>.github.io/<reponame>`.

 > P.S. инструкция взята с [этой статье](https://habr.com/ru/articles/799051/)

## Заключение
Репозиторий исходного кода доступен по [ссылке](https://github.com/alexeev-prog/hex64)
